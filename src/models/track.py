from music.constants import Dynamic
from models.note import Note
from typing import List, Optional
from music.durationtypes import QUARTER, SIXTEENTH

class TrackEvent:
    def __init__(self):
        pass

# class NoteEvent(TrackEvent, Note):
#     def __init__(self):
#         TrackEvent.__init__(self)
#         Note.__init__(self)

#         # hand effects
#         self.bend = 0          # pitch bend in half steps
#         self.bend_duration = 0  # bend duration in beats
#         self.bend_pattern = []  # percentage movement over bend duration time

#         # mute percentage
#         #   controls the weighting of the guitar muted track.
#         self.mute = 0

#         # harmonic track percentage
#         self.harmonic = 0


class StaffEvent(TrackEvent):
    def __init__(self):
        TrackEvent.__init__(self)
        self.bpm = 120
        self.signature = "4/4"
        self.key = "C"

        # workaround for a circular import error.
        from view.editor.glyphs.common import TREBLE_CLEFF

        self.cleff = TREBLE_CLEFF


class ChordEvent(TrackEvent):
    UPSTROKE = 0
    DOWNSTROKE = 1
    NOSTROKE = -1

    def __init__(self):
        super().__init__()
        self.stroke = self.DOWNSTROKE
        self.stroke_duration = 0  # in beats
        self.note_events = []


class EffectPresetEvent(TrackEvent):
    def __init__(self):
        super().__init__()


class AudioClipEvent(TrackEvent):
    def __init__(self):
        super().__init__()

        # play start and end
        self.start_pos = 0
        self.end_pos = 0
        self.loop = False
        self.filename = ""

class TabEvent(TrackEvent):
    FIRST_NOTE_COLUMN = 2
    BEND_PERIODS = 13

    REST = 0
    NOTE = 1
    CHORD = 2

    def classify(self):
        result = self.REST
        for val in self.fret:
            if val != -1:
                result += 1
                if result == self.CHORD:
                    break
        return result
        

    def __init__(self, num_gstrings):
        super().__init__()

        self.duration = QUARTER
        self.string = 5  # current string being edited
        self.fret = [-1] *  num_gstrings # current fret value
        self.note_duration = QUARTER
        self.pitch_bend_histogram = [0] * self.BEND_PERIODS
        self.pitch_bend_active = False
        self.presentation_col = self.FIRST_NOTE_COLUMN
        self.dotted = False
        self.double_dotted = False
        self.dynamic = Dynamic.MP
        self.triplet = False
        self.quintuplet = False
        self.legato = False
        self.staccato = False
        self.upstroke = False 
        self.downstroke = False
        self.stroke_duration = SIXTEENTH
        

class TrackEventSequence:
    """ 
    Events are generated by the UI, they result in this sequence being generated.

    This sequence is saved and used to generate a score.
    """

    def __init__(self):
        self.sequence = {}
        self.beatList = []
        
    def getActiveStaff(self, beat) -> StaffEvent | None:
        if beat in self.beatList:
            # starting at the current beat walk back
            # beat by beat till we reach a staff event.
            i = self.beatList.index(beat)
            while i > -1:
                beat = self.beatList[i]
                evtList = self.sequence[beat]
                for evt in evtList:
                    if isinstance(evt, StaffEvent):
                        return evt
                i -= 1

    def add(self, beat: int, evt : TrackEvent):
        evtList = self.sequence.get(beat, [])
        self.beatList.append(beat)
        evtList.append(evt)
        self.sequence[beat] = evtList
        self.beatList.sort()

    def get(self, beat: int) -> Optional[List[TrackEvent]]:
        return self.sequence.get(beat)

    def remove(self, beat: int, evt=None):
        if evt:
            evtList = self.sequence.get(beat)
            if evtList and evt in evtList:
                i = evtList.index(evt)
                del evtList[i]
        elif beat in self.sequence:
            del self.sequence[beat]



class Track:
    def __init__(self):
        self.uuid = None
        self.instrument_name = "Acoustic Guitar"
        self.tuning = [
            "E4",
            "B3",
            "G3",
            "D3",
            "A2",
            "E2"
        ]
        # beats from start of track -> [events]
        self.sequence = TrackEventSequence()
        self.active_beat = 0


    
    def createTabEvent(self, inherit = None, col=None) -> TabEvent:
        te = TabEvent(len(self.tuning))
        if inherit:
            te.note_duration = inherit.note_duration
            te.dynamic = inherit.dynamic 
            te.legato = inherit.legato
            te.staccato = inherit.stacatto
            te.triplet = inherit.triplet
            te.quintuplet = inherit.quintuplet
        if col:
            te.presentation_col = col
        return te

    def computeMidiCode(self, te : TabEvent):
        raise FutureWarning("TODO: compute midi code based on tuning")

    def setTuning(self, tuning):
        self.tuning = tuning  

    def getActiveBeat(self):
        return self.active_beat
    
    def setActiveBeat(self, beat):
        if self.sequence.get(beat):
            self.active_beat = beat
        else:
            raise ValueError("There is no track event for beat value %d" % beat)

    def getTabEvent(self, beat = None) -> TabEvent:
        """
        get the tablature event for a given beat  
        """
        if not beat:
            beat = self.active_beat 
        teList = self.sequence.get(beat)
        if teList:
            for te in teList:
                if isinstance(te,TabEvent):
                    return te
                
        raise ValueError("No track event for beat value %d" % beat)


    def getSequence(self) -> TrackEventSequence:
        return self.sequence
    
